# Stash Marker Studio v3.0 Plan

## Overview

Transform Stash Marker Studio from a lightweight companion app into a full-featured marker management system with its own PostgreSQL database, while maintaining Stashapp as the primary source of truth for core entities (scenes, performers, tags).

## Problem Statement

Current limitations:
- Stashapp player performance degrades with 100+ markers per scene
- No support for rich marker metadata beyond basic tags
- No way to link performers to specific markers (e.g., "who is wearing this dress?")
- Limited workflow support for AI-generated metadata
- No storage for AI analysis results (camera movement detection, YOLO scene/object detection)
- Slow marker searches and filtering

## Architecture Vision

### Data Layer Strategy

**Stashapp remains source of truth for:**
- Scenes (video files, metadata, basic info)
- Performers (identity, attributes)
- Tags (taxonomy, hierarchy)
- Studios, galleries, images

**New PostgreSQL database stores:**
- Extended marker data with rich metadata
- Marker slots and performer associations
- AI analysis results (camera movement, YOLO detections, etc.)
- PySceneDetect shot boundaries (keep these out of Stashapp)
- Marker search index for fast filtering
- Audit trail for marker changes
- Export status tracking (which markers synced to Stashapp)

**Synchronization model:**
- Manual import: Button to import markers from Stashapp to local DB (one-way)
- Selective export: Choose which markers to push to Stashapp (one-way)
- No automated sync: User controls when to import/export via UI buttons
- Rich metadata (slots, AI results) stays in local DB only
- Stashapp scene/performer/tag IDs stored in local DB for referential integrity

### Database Schema Design

#### Schema Philosophy

The schema uses a **hybrid approach** for marker and tag storage:

1. **Core tables mirror Stashapp's structure** (`markers`, `marker_tags`) - This ensures clean bidirectional sync by keeping field names and semantics aligned with Stashapp's GraphQL API
2. **Extension tables add rich metadata** (`marker_metadata`, `marker_slots`, etc.) - These are completely independent and never exported to Stashapp
3. **Sync tracking at marker level** - `last_synced_at` and `last_exported_at` on the `markers` table track when the entire marker (including all tags) was synced/exported, eliminating the need for per-tag sync timestamps

**Why this approach:**
- Stashapp operations are atomic (you import/export entire markers with all tags in one GraphQL call)
- Simple transformation layer between Stashapp GraphQL types and local DB schema
- Easy to detect conflicts and track dirty state
- Rich metadata extensions don't pollute the core sync logic

#### Core Tables

**markers** (mirrors Stashapp's SceneMarker)
- id (integer, primary key, autoincrement)
- stashapp_marker_id (integer, nullable, unique) - null for local-only markers not yet exported
- stashapp_scene_id (integer, not null) - references scene in Stashapp
- title (text, not null)
- seconds (decimal, not null) - start time (matches Stashapp field name)
- end_seconds (decimal, nullable) - end time (matches Stashapp field name)
- primary_tag_id (integer, nullable) - Stashapp's primary tag ID
- last_synced_at (timestamp, nullable) - last inbound sync from Stashapp
- last_exported_at (timestamp, nullable) - last outbound export to Stashapp
- created_at (timestamp)
- updated_at (timestamp)
- Indexes: stashapp_scene_id, stashapp_marker_id

**marker_tags** (mirrors Stashapp's tag relationships)
- id (integer, primary key, autoincrement)
- marker_id (integer, not null, references markers)
- tag_id (integer, not null) - Stashapp tag ID
- is_primary (boolean, default false)
- created_at (timestamp)
- updated_at (timestamp) - tracks when is_primary flag changes
- Unique: (marker_id, tag_id)
- Index: tag_id

**marker_slots**
- id (uuid, primary key)
- marker_id (uuid, references markers)
- slot_definition_id (uuid, references slot_definitions)
- stashapp_performer_id (integer, nullable) - references performer in Stashapp
- confidence (decimal, nullable) - AI confidence score 0-1
- notes (text, nullable)
- created_at (timestamp)
- updated_at (timestamp)

**slot_definitions**
- id (uuid, primary key)
- stashapp_tag_id (integer, not null) - which tag this slot applies to
- slot_name (text, not null) - e.g., "Wearer", "Performer", "Speaker"
- slot_type (enum: 'performer', 'tag', 'text', 'number')
- cardinality (enum: 'single', 'multiple')
- gender_hint (enum: 'any', 'male', 'female', 'non-binary', nullable)
- display_order (integer, default 0)
- created_at (timestamp)
- Unique: (stashapp_tag_id, slot_name)

**ai_analysis_results**
- id (uuid, primary key)
- marker_id (uuid, references markers, nullable) - null for scene-level analysis
- stashapp_scene_id (integer, not null)
- analysis_type (enum: 'camera_movement', 'yolo_detection', 'shot_classification', 'custom')
- model_name (text, not null) - e.g., "yolov8n", "optical_flow_v1"
- model_version (text, not null)
- result_data (jsonb, not null) - flexible storage for analysis results
- confidence (decimal, nullable)
- created_at (timestamp)

**sync_history**
- id (uuid, primary key)
- entity_type (enum: 'marker', 'import', 'export')
- entity_id (uuid, nullable) - marker id for marker operations, null for bulk import/export
- operation (enum: 'import_from_stashapp', 'export_to_stashapp')
- status (enum: 'success', 'failed')
- markers_count (integer, nullable) - for bulk operations
- error_message (text, nullable)
- synced_at (timestamp)

**Example YOLO result_data structure:**
```json
{
  "detections": [
    {
      "class": "bed",
      "confidence": 0.92,
      "bbox": [120, 340, 890, 650]
    },
    {
      "class": "person",
      "confidence": 0.87,
      "bbox": [200, 100, 450, 700]
    }
  ],
  "scene_classification": "bedroom",
  "indoor_outdoor": "indoor",
  "time_of_day": "night"
}
```

**Example camera movement result_data:**
```json
{
  "movement_type": "static",
  "movement_score": 0.05,
  "pan_detected": false,
  "zoom_detected": false,
  "camera_shake": 0.02
}
```

### Technology Stack

**Database:**
- PostgreSQL 15+ with UUID extension
- Prisma ORM for type-safe database access
- Database migrations via Prisma Migrate

**Backend:**
- Next.js API routes for database operations
- GraphQL client for Stashapp communication (keep existing StashappService)
- Optional: Background job queue for long-running AI workflows (consider simpler polling initially)

**Frontend:**
- Keep existing Redux architecture
- Add new slices for slot management, AI results
- Enhance marker components to display slots and AI metadata

### Migration Strategy

#### Phase 1: Database Foundation (v3.0-alpha)
- [x] Set up PostgreSQL with Docker Compose for development
- [x] Define Prisma schema matching above design
- [x] Create initial migration
- [x] Build database connection layer with runtime config injection
- [x] Create basic CRUD API routes for markers

#### Phase 2: Manual Import & Export (v3.0-beta.1)
- [x] Build "Import from Stashapp" button for scene markers
- [x] Import creates/updates local markers based on stashapp_marker_id
- [x] Switch app to read markers from local database instead of Stashapp
- [x] Update Redux slices to fetch from local API routes instead of StashappService
- [x] Update marker components to work with local database schema (API enriches with tag data)
- [x] Auto-sync local DB after Stashapp mutations (create/update/delete markers)
- [X] **Switch marker modifications to operate on local DB instead of Stashapp**
  - [X] Add API routes for local marker tag operations (confirm/reject/reset/add/remove tags)
  - [X] Update markerSlice thunks to modify local DB first instead of Stashapp
  - [X] Update marker creation/update/delete to work on local DB
  - [X] **Refactor to use local database IDs throughout instead of stashappMarkerId**
    - [X] Update GET /api/markers to return internal ID as marker.id
    - [X] Update all marker operation endpoints to use internal ID
    - [X] Ensure stashappMarkerId is only used for import/export sync

#### Phase 3: PySceneDetect Integration (v3.0-beta.2)
- [X] Store PySceneDetect results exclusively in local DB (marker_type='shot_boundary')
- [X] Update PySceneDetect script to write to local DB via API
- [X] Build UI for viewing shot boundaries without exporting to Stashapp

#### Phase 4: Slotted Markers System (v3.0-beta.3)

**Overview**: Allow users to define performer slots for markers based on primary tags. Each slotted marker can have multiple performer slots with labels and optional gender hints.

**Terminology**:
- **Slotted Marker**: A marker with defined performer slots
- **Performer Slot**: A slot that can hold 0-1 performer
- **Slot Label**: The name/role of the slot (e.g., "Wearer", "Participant 1", "Giver", "Receiver")
- **Gender Hint**: Optional constraint on slot using Stashapp genders (MALE, FEMALE, TRANSGENDER_FEMALE, TRANSGENDER_MALE)

**Design Principles**:
- Slot definitions are configured per primary tag in Settings
- All markers with same primary tag share the same slot definitions
- Slots are optional to fill (no required slots)
- Each slot holds 0-1 performer
- For multiple performers in same role, define multiple slots with similar labels (e.g., "Participant 1", "Participant 2")
- Gender hints are advisory/filtering aids, not hard constraints
- No cardinality system needed - if multiple performers needed, just define multiple slots

**Examples**:
```typescript
// "Dress" tag with single slot
{
  primaryTag: "Dress",
  performerSlots: [
    { label: "Wearer", genderHint: "FEMALE" }
  ]
}

// "Conversation" tag with multiple slots
{
  primaryTag: "Conversation",
  performerSlots: [
    { label: "Participant 1", genderHint: null },
    { label: "Participant 2", genderHint: null },
    { label: "Participant 3", genderHint: null }
  ]
}

// Activity tag with gender hints
{
  primaryTag: "Oral",
  performerSlots: [
    { label: "Giver", genderHint: null },
    { label: "Receiver", genderHint: "MALE" }
  ]
}
```

**Implementation Tasks**:
- [X] Update database schema for slotted markers
  - [X] Create `slot_definitions` table with slot_label field
  - [X] Create GenderHint enum (MALE, FEMALE, TRANSGENDER_MALE, TRANSGENDER_FEMALE)
  - [X] Create `marker_slots` table for performer assignments
  - [X] Add markerSlots relation to Marker model
- [X] Build slot definitions CRUD API
  - [X] GET /api/slot-definitions - list all slot definitions (with optional tagId filter)
  - [X] POST /api/slot-definitions - create slot definition for a tag
  - [X] GET /api/slot-definitions/:id - get specific slot definition
  - [X] PUT /api/slot-definitions/:id - update slot definition
  - [X] DELETE /api/slot-definitions/:id - delete slot definition
  - [X] GET /api/markers/:id/slots - get slots for a marker
  - [X] POST /api/markers/:id/slots - create/update slots for a marker (atomic replace)
- [X] Build Settings UI for slot definitions
  - [X] Add "Slot Definitions" tab to Settings page (/config/slot-definitions)
  - [X] Tag autocomplete selector using Stashapp tags from Redux
  - [X] Tag-based workflow: select tag â†’ edit all slots â†’ save atomically
  - [X] Slot editor with add/remove slots dynamically
  - [X] Up/down buttons for reordering slots
  - [X] Gender hint dropdown with friendly labels (Male, Female, Transgender Male, Transgender Female)
  - [X] Summary view of all tags with slot definitions when no tag selected
- [X] Create TypeScript types for slot system
  - [X] GenderHint type exported from core/slot/types.ts
  - [X] SlotDefinition interface
  - [X] MarkerSlot interface
  - [X] MarkerSlotWithPerformer interface
- [X] Add slot display to marker views
  - [X] Show assigned performers in marker list view as badges
  - [X] Extend GET /api/markers to include slot data with performer info
  - [X] Add performers to Redux store (loaded during initialization)
- [X] Build slot assignment infrastructure
  - [X] Create PerformerAutocomplete component with gender filtering
  - [X] Create MarkerSlotsDialog for dedicated slot assignment UI
  - [X] Add slotAssignment modal state to Redux
  - [X] API endpoint /api/markers/[id]/slots already exists for updates
- [X] Integrate slot assignment into workflow
  - [X] Add 'g' keyboard shortcut to open slot assignment dialog
  - [X] Wire up dialog save handler to update slots via API
  - [X] Refresh markers after slot updates
- [X] Polish slot system
  - [X] Make slot labels optional (some tags like "Dress" don't need labels)
  - [X] Update slot definitions in place instead of delete+recreate (preserves marker slots)
  - [X] Display fallback labels ("Slot 1", "Slot 2") when no label provided
- [ ] Remove temporary slot editing from TempMarkerForm
- [ ] Limit performers list to only show performers assigned to the scene in Stashapp

#### Phase 5: Export to Stashapp (v3.0-beta.4)
- [ ] Build "Export to Stashapp" button for selected markers (basic tags only)
- [ ] Add sync history logging
- [ ] UI indicators for export status (never exported, exported, modified since export)

#### Phase 6: AI Workflows Foundation (v3.0-beta.5)
- [ ] Design AI workflow runner architecture
- [ ] Implement camera movement detection workflow
- [ ] Store results in ai_analysis_results table
- [ ] Build AI results viewer component
- [ ] Add AI-powered marker filtering (e.g., "show only static shots")

#### Phase 7: YOLO Integration (v3.0-rc.1)
- [ ] Integrate YOLO model for object/scene detection
- [ ] Build workflow for batch processing scenes
- [ ] Store detections in ai_analysis_results
- [ ] Create UI for browsing scenes by detected objects/locations
- [ ] Add auto-tagging suggestions based on YOLO results

#### Phase 8: Performance & Search (v3.0-rc.2)
- [ ] Add database indexes for common queries
- [ ] Implement full-text search for markers
- [ ] Build advanced filter UI (by slots, AI results, tags)
- [ ] Add pagination for large marker sets
- [ ] Performance testing with 1000+ markers per scene

#### Phase 9: Polish & Release (v3.0)
- [ ] Migration guide from v2.x to v3.0
- [ ] Database backup/restore utilities
- [ ] Comprehensive error handling for sync failures
- [ ] Documentation for slot definitions and AI workflows
- [ ] Docker Compose setup for production deployment

### API Design Examples

**Create marker with slots:**
```typescript
POST /api/markers
{
  "stashapp_scene_id": 123,
  "title": "Blue dress sequence",
  "start_time": 45.5,
  "end_time": 67.3,
  "marker_type": "action",
  "tags": [
    { "stashapp_tag_id": 456, "is_primary": true } // "Dress" tag
  ],
  "slots": [
    {
      "slot_definition_id": "uuid-for-wearer-slot",
      "stashapp_performer_id": 789
    }
  ],
  "exported_to_stashapp": false
}
```

**Query markers with rich filters:**
```typescript
GET /api/markers?scene_id=123&marker_type=shot_boundary&has_ai_analysis=camera_movement&movement_type=static&limit=50&offset=0
```

**Sync markers to Stashapp:**
```typescript
POST /api/sync/export-markers
{
  "marker_ids": ["uuid1", "uuid2", "uuid3"],
  "sync_mode": "selective" // or "all_pending"
}
```

### Configuration Updates

**Environment variables:**
```env
# Existing Stashapp config
STASHAPP_SERVER_URL=http://localhost:9999
STASHAPP_API_KEY=...

# New database config
DATABASE_URL=postgresql://user:pass@localhost:5432/stashmarker

# AI workflow config (optional)
AI_WORKFLOWS_ENABLED=true
YOLO_MODEL_PATH=/models/yolov8n.pt
CAMERA_MOVEMENT_THRESHOLD=0.1
```

### UI/UX Enhancements

**Scene Header:**
- "Import Markers from Stashapp" button
- "Export Selected to Stashapp" button
- Import/export operation status messages

**Marker List View:**
- Export status icons (âœ“ exported, âš  modified, â†» never exported)
- Display slot summary badges (e.g., "ðŸ‘¤ Jane Doe")
- Filter by export status
- Checkbox selection for bulk export

**Marker Detail View:**
- Slot editor panel
- AI analysis results panel (collapsible)
- Export status indicator
- "Export to Stashapp" button (exports only basic marker + tags)

**New Views:**
- Slot Definitions Manager (admin panel)
- AI Workflow Dashboard (trigger analysis, view results)
- Sync History Log (import/export operations, errors)
- Scene Browser by AI Results (e.g., "all bedroom scenes", "all static shots")

### Open Questions & Decisions Needed

1. **Import Behavior**: When importing from Stashapp, should we:
   - Skip markers already in local DB (by stashapp_marker_id)?
   - Update existing markers if Stashapp version has changed?
   - Prompt user for merge/overwrite decisions?

2. **AI Workflow Execution**: Run locally in Next.js, or separate Python service? Consider model size and performance.

3. **Slot Definition Management**: Should users define custom slots via UI, or hardcoded/config-based initially?

4. **Database Hosting**: Self-hosted PostgreSQL only, or support managed services (RDS, Supabase)?

5. **Performance Target**: How many markers per scene should we optimize for? 100? 1000? 10,000?

6. **Export Granularity**: When exporting, what gets sent to Stashapp?
   - Basic markers only (title, times, basic tags)
   - Exclude slot data, AI results (stays local)
   - How to handle markers with rich metadata on re-export?

### Breaking Changes from v2.x

- Requires PostgreSQL installation
- Requires database migration on first run
- Environment variables must include DATABASE_URL
- Markers will initially be imported from Stashapp (one-time process)
- PySceneDetect workflow changes to write to local DB instead of directly to Stashapp

### Non-Goals (Future Versions)

- Replace Stashapp entirely (remain a companion app)
- Support for non-Stashapp video sources
- Real-time collaborative marker editing (multi-user)
- Mobile app support
- Marker sharing/export to other users

---

## Implementation Notes

This is a major architectural shift. Consider:
- Create feature branch `v3-database-layer` for development
- Keep v2.x stable in main branch during development
- Regular backups during migration testing
- Performance benchmarks before and after migration
- User testing with large marker datasets (1000+ markers)

The phased approach allows shipping incremental value while building toward the full vision.
